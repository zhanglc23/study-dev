package com.ivan.study.es;

import com.ivan.study.Msg;
import com.ivan.study.MsgType;
import com.ivan.study.RegexUtil;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.client.transport.TransportClient;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.transport.InetSocketTransportAddress;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.sort.SortOrder;
import org.elasticsearch.xpack.client.PreBuiltXPackTransportClient;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutionException;

/**
 * Description:
 * author zhanglc
 * Created on 2018/8/13.
 */

public class XOpenTest {
    private static Logger logger = LogManager.getLogger(Class.class);

    public static void main(String[] args) throws UnknownHostException {

        String index = "index-acmadm-filebeat-2018.08.12-doc";

        Settings settings = Settings.builder()
                .put("client.transport.sniff", true)
                .put("client.transport.ignore_cluster_name", true)
                .put("xpack.security.user", "Qindex2:Q_index099_TT").build();
        TransportClient client = new PreBuiltXPackTransportClient(settings)
                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName("172.16.76.14"), 9300));

        //查询前置，如果是开销户就发送，记账下次发送，查询直接跳过
        BoolQueryBuilder type = QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery("response"))
                .must(QueryBuilders.termsQuery("txCd", "0130001", "0130002", "0130015", "0130000"));
        logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>acmt std open woacc is start<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
        SearchResponse xrsp = client.prepareSearch(index).setQuery(type).setSearchType(SearchType.DFS_QUERY_THEN_FETCH)
                .setSize(1000).execute().actionGet();

        long totalHits = xrsp.getHits().getTotalHits();
        int page = (int) totalHits / (5 * 1000);
        long count = 0L;
        logger.info("std open woacc total = {} , totalpage = {}", totalHits, page);

        SearchHits searchHits = xrsp.getHits();
        SearchHit[] hits = searchHits.getHits();

        if (hits.length > 0) {
            for (int j = 0; j < hits.length; j++) {
                SearchHit hit = hits[j];
                Msg reqMsg = getMsg(hit, MsgType.REQ, null);
                String msgId = (String) hit.getSource().get("msgId");
                BoolQueryBuilder rm = QueryBuilders.boolQuery().must(QueryBuilders.existsQuery("response"))
                        .must(QueryBuilders.matchPhraseQuery("msgId", msgId));
                SearchResponse frp = client.prepareSearch(index).setQuery(rm).execute().actionGet();
                SearchHits shits = frp.getHits();
                SearchHit[] hits2 = shits.getHits();
                if (hits2.length > 0) {
                    for (int m = 0; m < hits2.length; m++) {
                        SearchHit h = hits2[m];
                        Msg rspmsg = getMsg(h, MsgType.RSP, reqMsg);
                        reqMsg.setAccDate(rspmsg.getAccDate());
                        logger.info("std open woacc req  size = {} , NO = {} , msg = {}",  hits2.length, j, reqMsg);
                        logger.info("std open woacc rsp  size = {} , NO = {} , msg = {}",  hits2.length, j, rspmsg);
                    }
                } else {
                    logger.warn("std open woacc no response size = {} , NO = {} ",  hits.length, j);
                }
            }
        }
    }

    private static Msg getMsg(SearchHit hit, MsgType msgType, Msg reqMsg) {
        String time = (String) hit.getSource().get("@timestamp");
        String source = (String) hit.getSource().get("log_source");
        String msgId = (String) hit.getSource().get("msgId");
        String type;
        logger.info("------------{}" , hit.getSource().get("message"));
        String message = getXMLReqMsg(((String) hit.getSource().get("message")).replaceAll(RegexUtil.SPACE_OR_ENTER, ""));
        String accDate = null;
        if (MsgType.REQ.equals(msgType)) {
            type = ((String) hit.getSource().get("txCd")).substring(0 , 7);
        } else {
            type = reqMsg.getTxCode();
            accDate = message.substring(message.indexOf("<AC_DT>")+7, message.indexOf("</AC_DT>"));
        }
        return new Msg(time, source, msgId, message, msgType, accDate, type);
    }

    private static String getXMLReqMsg(String message) {
        return RegexUtil.getSubStr(message, RegexUtil.RGEX_XMLMSG_REQ);
    }
}


//System.out.println("scroll 模式启动！");
//        begin = new Date();
//        SearchResponse scrollResponse = client.prepareSearch(INDEX)
//        .setSearchType(SearchType.SCAN).setSize(10000).setScroll(TimeValue.timeValueMinutes(1))
//        .execute().actionGet();
//        count = scrollResponse.getHits().getTotalHits();//第一次不返回数据
//        for(int i=0,sum=0; sum<count; i++){
//        scrollResponse = client.prepareSearchScroll(scrollResponse.getScrollId())
//        .setScroll(TimeValue.timeValueMinutes(8))
//        .execute().actionGet();
//        sum += scrollResponse.getHits().hits().length;
//        System.out.println("总量"+count+" 已经查到"+sum);
//        }
//        end = new Date();
//        System.out.println("耗时: "+(end.getTime()-begin.getTime()))
